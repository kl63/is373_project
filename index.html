<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Beginners Guide to Devops</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Beginners Guide to Devops">
<meta property="og:url" content="https://kl63.github.io/is373_project/index.html">
<meta property="og:site_name" content="Beginners Guide to Devops">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Kevin Lin &amp; Sebastian Lopez">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/is373_project/atom.xml" title="Beginners Guide to Devops" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/is373_project/favicon.png">
  
  
  
<link rel="stylesheet" href="/is373_project/css/style.css">

  
    
<link rel="stylesheet" href="/is373_project/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/is373_project/" id="logo">Beginners Guide to Devops</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/is373_project/">Home</a>
        
          <a class="main-nav-link" href="/is373_project/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/is373_project/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://kl63.github.io/is373_project"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-12-factor" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/is373_project/2024/10/13/12-factor/" class="article-date">
  <time class="dt-published" datetime="2024-10-13T01:32:23.273Z" itemprop="datePublished">2024-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/is373_project/2024/10/13/12-factor/">Twelve Factor App</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/is373_project/images/12-factor.png" alt="Twelve-Factor App"></p>
<p>The Twelve-Factor App methodology defines best practices for building scalable and maintainable SaaS applications:</p>
<ol>
<li><strong>Codebase</strong>: One codebase tracked in revision control, many deploys.  </li>
<li><strong>Dependencies</strong>: Explicitly declare and isolate dependencies.  </li>
<li><strong>Config</strong>: Store config in the environment.  </li>
<li><strong>Backing services</strong>: Treat backing services as attached resources.  </li>
<li><strong>Build, release, run</strong>: Separate build and run stages.  </li>
<li><strong>Processes</strong>: Execute the app as one or more stateless processes.  </li>
<li><strong>Port binding</strong>: Export services via port binding.  </li>
<li><strong>Concurrency</strong>: Scale out via the process model.  </li>
<li><strong>Disposability</strong>: Maximize robustness with fast startup and graceful shutdown.  </li>
<li><strong>Dev&#x2F;prod parity</strong>: Keep development, staging, and production environments similar.  </li>
<li><strong>Logs</strong>: Treat logs as event streams.  </li>
<li><strong>Admin processes</strong>: Run admin tasks as one-off processes.</li>
</ol>
<p>Learn more at <a target="_blank" rel="noopener" href="https://12factor.net/">here</a>.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kl63.github.io/is373_project/2024/10/13/12-factor/" data-id="cm26wuol80000fnoy0qzoadrr" data-title="Twelve Factor App" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-containerization" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/is373_project/2024/10/13/containerization/" class="article-date">
  <time class="dt-published" datetime="2024-10-13T01:32:23.273Z" itemprop="datePublished">2024-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/is373_project/2024/10/13/containerization/">Containerization</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/is373_project/images/containerization.jpg" alt="Containerization"></p>
<p><strong>Containerization</strong> allows applications to run in isolated environments called containers. Unlike virtual machines, containers share the host OS kernel but have their own file system, network, and process space.</p>
<h2 id="Key-Concepts"><a href="#Key-Concepts" class="headerlink" title="Key Concepts:"></a>Key Concepts:</h2><ul>
<li><strong>Docker</strong>: A popular platform for containerization.</li>
<li><strong>Images</strong>: Immutable snapshots defining a container’s contents.</li>
<li><strong>Containers</strong>: Instances of Docker images running in isolated environments.</li>
<li><strong>Registry</strong>: A repository for Docker images (e.g., Docker Hub).</li>
</ul>
<h2 id="Benefits"><a href="#Benefits" class="headerlink" title="Benefits:"></a>Benefits:</h2><ul>
<li><strong>Lightweight</strong>: Containers are smaller and faster than VMs.</li>
<li><strong>Consistency</strong>: Ensures the same behavior across environments.</li>
<li><strong>Efficiency</strong>: Uses fewer resources by sharing the OS kernel.</li>
<li><strong>Scalability</strong>: Easily scale applications by spinning up more containers.</li>
</ul>
<h3 id="History-of-Containerization"><a href="#History-of-Containerization" class="headerlink" title="History of Containerization"></a>History of Containerization</h3><ul>
<li><strong>1979</strong>: Unix chroot introduced file system isolation.</li>
<li><strong>2000s</strong>: Linux introduced containers with cgroups and namespaces.</li>
<li><strong>2013</strong>: Docker revolutionized containerization with its platform.</li>
<li><strong>Present</strong>: Containerization is critical for microservices and DevOps.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kl63.github.io/is373_project/2024/10/13/containerization/" data-id="cm26wuolc0001fnoyf0zicyf0" data-title="Containerization" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-docker" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/is373_project/2024/10/13/docker/" class="article-date">
  <time class="dt-published" datetime="2024-10-13T01:32:23.273Z" itemprop="datePublished">2024-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/is373_project/2024/10/13/docker/">Docker</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/is373_project/images/docker.png" alt="Docker "></p>
<p>The Docker logo represents the platform’s emphasis on containerization and automation. The logo features a whale carrying containers, symbolizing Docker’s core functionality of managing and deploying containers.</p>
<ul>
<li><p><strong>Definition</strong>: Docker is an open-source platform that automates the deployment, scaling, and management of applications through containerization. By packaging applications and their dependencies into isolated units called containers, Docker enables consistent operation across various computing environments, from local development machines to cloud-based production systems.</p>
</li>
<li><p><strong>Key Features</strong>:</p>
<ul>
<li><p><strong>Isolation</strong>: Docker containers provide a lightweight form of virtualization by isolating applications and their dependencies in separate environments. This isolation prevents conflicts between applications and ensures that they run independently without affecting one another. Each container encapsulates everything needed to run an application, including the code, runtime, libraries, and environment variables.</p>
</li>
<li><p><strong>Consistency</strong>: Containers are designed to operate consistently across different environments. Whether running on a developer’s laptop, a test server, or a production environment, Docker ensures that the application behaves the same way. This consistency reduces issues related to “it works on my machine” and streamlines the development and deployment process.</p>
</li>
<li><p><strong>Efficiency</strong>: Unlike traditional virtual machines (VMs), Docker containers share the host system’s operating system kernel. This shared resource model makes containers more lightweight and faster to start compared to VMs, which require their own full operating system. Containers use less memory and disk space, making them a more resource-efficient option for running multiple applications on a single host.</p>
</li>
</ul>
</li>
<li><p><strong>Components</strong>:</p>
<ul>
<li><p><strong>Docker Engine</strong>: The core component of Docker that handles container creation, execution, and management. It consists of a server, a REST API, and a command-line interface (CLI) for interacting with the Docker daemon.</p>
</li>
<li><p><strong>Docker Images</strong>: Immutable snapshots of a file system that include everything needed to run an application, such as the code, runtime, libraries, and environment variables. Docker images are used to create containers and can be shared through Docker Hub or other container registries.</p>
</li>
<li><p><strong>Docker Containers</strong>: Running instances of Docker images. Containers are lightweight, portable, and can be started or stopped quickly. They encapsulate an application and its dependencies in a standardized environment.</p>
</li>
<li><p><strong>Dockerfile</strong>: A text file containing a set of instructions for building Docker images. It specifies the base image, application code, dependencies, and configuration steps required to create a custom image.</p>
</li>
<li><p><strong>Docker Compose</strong>: A tool that simplifies the management of multi-container applications. It allows developers to define and manage multi-container setups using a YAML configuration file, making it easier to handle complex applications with interconnected services.</p>
</li>
</ul>
</li>
<li><p><strong>Benefits</strong>:</p>
<ul>
<li><p><strong>Portability</strong>: Docker containers can run on any system that supports Docker, regardless of the underlying infrastructure. This portability facilitates the movement of applications between different environments and clouds.</p>
</li>
<li><p><strong>Scalability</strong>: Docker enables scalable applications by allowing developers to deploy multiple instances of containers across clusters. This horizontal scaling improves performance and reliability.</p>
</li>
<li><p><strong>Version Control</strong>: Docker images can be versioned and stored in container registries, making it easy to track changes, roll back to previous versions, and maintain consistent deployments.</p>
</li>
</ul>
</li>
<li><p><strong>Use Cases</strong>:</p>
<ul>
<li><p><strong>Development and Testing</strong>: Docker simplifies the setup of development and testing environments by providing consistent and reproducible environments across different stages of the software lifecycle.</p>
</li>
<li><p><strong>Continuous Integration&#x2F;Continuous Deployment (CI&#x2F;CD)</strong>: Docker integrates seamlessly with CI&#x2F;CD pipelines, automating the process of building, testing, and deploying applications. This integration streamlines the delivery process and enhances deployment reliability.</p>
</li>
<li><p><strong>Microservices Architecture</strong>: Docker supports microservices by allowing developers to deploy and manage multiple interdependent services in separate containers. This architecture improves modularity and scalability of applications.</p>
</li>
</ul>
</li>
<li><p><strong>Ecosystem</strong>:</p>
<ul>
<li><p><strong>Docker Hub</strong>: A cloud-based repository that hosts Docker images. Docker Hub provides a central location for storing and sharing container images, making it easier to access pre-built images and collaborate with others.</p>
</li>
<li><p><strong>Kubernetes</strong>: An open-source container orchestration platform that works with Docker to manage and scale containerized applications. Kubernetes automates deployment, scaling, and operations of application containers across clusters of hosts.</p>
</li>
</ul>
</li>
</ul>
<p>Docker’s innovative approach to containerization has revolutionized the way applications are developed, deployed, and managed, offering a powerful toolset for modern software development and operations.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kl63.github.io/is373_project/2024/10/13/docker/" data-id="cm26wuole0002fnoyhtonasun" data-title="Docker" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-dockervskubernetes" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/is373_project/2024/10/13/dockervskubernetes/" class="article-date">
  <time class="dt-published" datetime="2024-10-13T01:32:23.273Z" itemprop="datePublished">2024-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/is373_project/2024/10/13/dockervskubernetes/">Docker vs Kubernetes: Pros and Cons</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/is373_project/images/dockervskubernetess.jpeg.webp" alt="Docker vs Kubernetes Graphic"></p>
<p>Both <strong>Docker</strong> and <strong>Kubernetes</strong> are essential tools in the containerization ecosystem, but they serve different purposes. Docker focuses on creating, deploying, and managing containers, while Kubernetes is designed to orchestrate and manage containers at scale. Understanding the strengths and weaknesses of each tool is crucial when deciding which one to use for your projects.</p>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><strong>Docker</strong> is a platform that enables developers to easily package applications and their dependencies into containers. A container is a lightweight, portable, and isolated environment in which an application can run, making Docker a convenient tool for local development, testing, and deployment.</p>
<h3 id="Pros"><a href="#Pros" class="headerlink" title="Pros"></a>Pros</h3><ul>
<li><strong>Ease of Use</strong>: Docker is known for its simplicity, making it easy for developers to get started. With a simple CLI, developers can create, deploy, and manage containers without needing to understand complex infrastructure.</li>
<li><strong>Portability</strong>: Containers created with Docker can run anywhere, from your local machine to the cloud. This ensures consistent environments, preventing the “it works on my machine” issue.</li>
<li><strong>Efficiency</strong>: Docker containers share the host OS kernel, which makes them more resource-efficient compared to virtual machines (VMs). This allows multiple containers to run on a single host without heavy resource consumption.</li>
<li><strong>Wide Ecosystem</strong>: Docker has a large, active community and many integrations with CI&#x2F;CD pipelines, cloud platforms, and monitoring tools.</li>
</ul>
<h3 id="Cons"><a href="#Cons" class="headerlink" title="Cons"></a>Cons</h3><ul>
<li><strong>Limited Orchestration</strong>: Docker alone doesn’t provide sophisticated tools to manage clusters of containers. Docker Swarm, Docker’s native orchestration tool, exists, but it’s not as powerful or widely used as Kubernetes.</li>
<li><strong>Manual Scaling</strong>: While Docker allows containers to be spun up quickly, it requires manual intervention or additional tools to manage large-scale deployments or handle complex networking configurations.</li>
</ul>
<h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><p><strong>Kubernetes</strong>, often abbreviated as <strong>K8s</strong>, is an open-source platform that automates the deployment, scaling, and operation of containerized applications. It is designed to manage containerized applications across clusters of machines, ensuring that everything runs smoothly and scales efficiently.</p>
<h3 id="Pros-1"><a href="#Pros-1" class="headerlink" title="Pros"></a>Pros</h3><ul>
<li><strong>High Scalability</strong>: Kubernetes is designed for managing large clusters of containers across multiple nodes. It can handle the scaling of applications based on demand and is well-suited for complex, large-scale deployments.</li>
<li><strong>Self-Healing</strong>: Kubernetes automatically detects failures in containers and restarts them as necessary. It can roll back problematic updates and ensure the system maintains its desired state.</li>
<li><strong>Advanced Orchestration</strong>: Kubernetes provides sophisticated features like rolling updates, automatic scaling, and service discovery, making it a robust tool for orchestrating complex, distributed applications.</li>
<li><strong>Load Balancing</strong>: Kubernetes automatically distributes incoming traffic across your containers, ensuring optimal performance and availability.</li>
</ul>
<h3 id="Cons-1"><a href="#Cons-1" class="headerlink" title="Cons"></a>Cons</h3><ul>
<li><strong>Steep Learning Curve</strong>: Kubernetes can be difficult to learn, especially for teams new to container orchestration. The setup, configuration, and management of clusters require an in-depth understanding of Kubernetes concepts.</li>
<li><strong>Resource Intensive</strong>: Running a Kubernetes cluster can be overkill for smaller applications or development environments. The overhead of setting up and maintaining the infrastructure can outweigh the benefits for smaller projects.</li>
<li><strong>Complex Setup</strong>: Unlike Docker, which is straightforward to install and use, setting up a Kubernetes cluster can be time-consuming and requires careful planning. Even managed Kubernetes services (like GKE or EKS) require knowledge to configure effectively.</li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In summary, Docker is perfect for developers who need a simple way to package, ship, and run applications in isolated environments. It excels in ease of use, portability, and resource efficiency. However, when it comes to scaling, managing, and orchestrating large clusters of containers, <strong>Kubernetes</strong> is the better choice due to its powerful orchestration capabilities, self-healing features, and scalability. </p>
<p>For small to medium projects, Docker may suffice, but for larger, production-level applications that need complex orchestration, Kubernetes is a more appropriate solution.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kl63.github.io/is373_project/2024/10/13/dockervskubernetes/" data-id="cm26wuolf0003fnoy2o423ymt" data-title="Docker vs Kubernetes: Pros and Cons" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-kernel" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/is373_project/2024/10/13/kernel/" class="article-date">
  <time class="dt-published" datetime="2024-10-13T01:32:23.273Z" itemprop="datePublished">2024-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/is373_project/2024/10/13/kernel/">Kernel Operating Systems</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/is373_project/images/Kernel_Layout.svg.png" alt="Kernel OS Diagram"></p>
<h2 id="Kernel-Layer"><a href="#Kernel-Layer" class="headerlink" title="Kernel Layer"></a>Kernel Layer</h2><ul>
<li><strong>Definition</strong>: The kernel is the core component of an operating system (OS). It manages the system’s hardware resources and enables software applications to interact with hardware components.</li>
<li><strong>Key Functions</strong>:<ul>
<li><strong>Resource Management</strong>: Allocates CPU time, memory space, and I&#x2F;O resources to various processes and applications.</li>
<li><strong>Process Management</strong>: Handles the creation, scheduling, and termination of processes. It ensures that processes run efficiently and without interference.</li>
<li><strong>Memory Management</strong>: Manages the system’s memory, including RAM and virtual memory, to ensure that processes have the necessary memory resources and to optimize performance.</li>
<li><strong>Device Management</strong>: Acts as an intermediary between applications and hardware devices such as printers, disk drives, and network interfaces.</li>
<li><strong>System Calls</strong>: Provides an interface for applications to request services from the kernel, such as file operations or process control.</li>
</ul>
</li>
</ul>
<h2 id="Application-Layer"><a href="#Application-Layer" class="headerlink" title="Application Layer"></a>Application Layer</h2><ul>
<li><strong>Definition</strong>: The application layer consists of the software applications that users interact with. These applications rely on the kernel to perform low-level tasks and manage hardware resources.</li>
<li><strong>Key Functions</strong>:<ul>
<li><strong>User Interaction</strong>: Provides the interface through which users interact with the computer, including graphical user interfaces (GUIs) and command-line interfaces.</li>
<li><strong>Application Execution</strong>: Runs user-facing programs, such as web browsers, word processors, and games, which utilize the services provided by the kernel.</li>
<li><strong>Communication</strong>: Interfaces with the kernel to perform operations like file management, networking, and device interaction.</li>
</ul>
</li>
</ul>
<h2 id="Relationship-Between-Layers"><a href="#Relationship-Between-Layers" class="headerlink" title="Relationship Between Layers"></a>Relationship Between Layers</h2><ul>
<li><strong>Communication</strong>: The application layer communicates with the kernel through system calls. When an application needs to perform a task that involves hardware (e.g., reading a file or sending data over a network), it makes a system call to request the kernel’s assistance.</li>
<li><strong>Abstraction</strong>: The kernel abstracts the complexities of hardware management from the application layer, allowing developers to create software without needing to manage hardware directly.</li>
<li><strong>Security and Stability</strong>: The kernel provides a layer of protection and control to ensure that applications cannot directly access or interfere with hardware resources, enhancing the system’s security and stability.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kl63.github.io/is373_project/2024/10/13/kernel/" data-id="cm26wuolg0004fnoy4o319cs4" data-title="Kernel Operating Systems" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-scaling" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/is373_project/2024/10/13/scaling/" class="article-date">
  <time class="dt-published" datetime="2024-10-13T01:32:23.273Z" itemprop="datePublished">2024-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/is373_project/2024/10/13/scaling/">Scaling: Horizontal vs. Vertical</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/is373_project/images/scaling.png" alt="Scaling"></p>
<h2 id="Vertical-Scaling"><a href="#Vertical-Scaling" class="headerlink" title="Vertical Scaling"></a>Vertical Scaling</h2><p><strong>Definition</strong>: Vertical scaling involves adding more power to a single machine, such as increasing CPU, RAM, or storage capacity.</p>
<h3 id="Pros"><a href="#Pros" class="headerlink" title="Pros"></a>Pros</h3><ul>
<li><strong>Simplicity</strong>: Easier to implement as it involves upgrading the existing machine without requiring changes to the application.</li>
<li><strong>No App Changes</strong>: Existing applications generally do not need modifications to benefit from increased resources.</li>
</ul>
<h3 id="Cons"><a href="#Cons" class="headerlink" title="Cons"></a>Cons</h3><ul>
<li><strong>Capacity Limitations</strong>: Limited by the maximum capacity of the machine. There’s a physical limit to how much power a single machine can handle.</li>
<li><strong>Cost</strong>: Upgrading hardware can be expensive, especially for high-end components.</li>
<li><strong>Single Point of Failure</strong>: If the machine fails, the entire application or service can become unavailable.</li>
</ul>
<h2 id="Horizontal-Scaling"><a href="#Horizontal-Scaling" class="headerlink" title="Horizontal Scaling"></a>Horizontal Scaling</h2><p><strong>Definition</strong>: Horizontal scaling involves adding more machines to distribute the load and increase capacity.</p>
<h3 id="Pros-1"><a href="#Pros-1" class="headerlink" title="Pros"></a>Pros</h3><ul>
<li><strong>Fault Tolerance</strong>: Enhanced reliability and fault tolerance since the application is distributed across multiple machines. Failure of one machine does not bring down the entire system.</li>
<li><strong>Traffic Handling</strong>: Better suited for handling increased traffic and load by distributing the workload among several machines.</li>
<li><strong>Scalability</strong>: Easier to scale out by adding more machines as needed.</li>
</ul>
<h3 id="Cons-1"><a href="#Cons-1" class="headerlink" title="Cons"></a>Cons</h3><ul>
<li><strong>Complexity</strong>: More complex to implement and manage. Requires designing the application to work in a distributed environment.</li>
<li><strong>Distributed App Design</strong>: Needs changes to the application architecture, such as implementing load balancing, distributed databases, and network configurations.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kl63.github.io/is373_project/2024/10/13/scaling/" data-id="cm26wuolh0005fnoyh1abfuzr" data-title="Scaling: Horizontal vs. Vertical" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-threading" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/is373_project/2024/10/13/threading/" class="article-date">
  <time class="dt-published" datetime="2024-10-13T01:32:23.273Z" itemprop="datePublished">2024-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/is373_project/2024/10/13/threading/">Threading</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>Threading</strong> allows a single process to perform multiple tasks simultaneously using separate threads.</p>
<ul>
<li><p><strong>Benefits</strong>:</p>
<ul>
<li><strong>Improved Performance</strong>: By running multiple threads in parallel, applications can complete tasks more quickly, making better use of available CPU resources.</li>
<li><strong>Responsiveness</strong>: Threads can handle multiple operations at once, improving the responsiveness of applications, especially in interactive or real-time systems.</li>
</ul>
</li>
<li><p><strong>How It Works</strong>:</p>
<ul>
<li><strong>Shared Memory</strong>: Threads within the same process share the same memory space, allowing them to access and modify shared data. This facilitates communication between threads but also requires careful management.</li>
<li><strong>Thread Management</strong>: Proper management is needed to avoid conflicts such as race conditions (where threads access shared data simultaneously) and deadlocks (where threads wait indefinitely for resources held by each other). Techniques like synchronization mechanisms (e.g., mutexes, semaphores) are used to manage access to shared resources and ensure thread safety.</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kl63.github.io/is373_project/2024/10/13/threading/" data-id="cm26wuolh0006fnoy2tfzedix" data-title="Threading" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ubuntu" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/is373_project/2024/10/13/ubuntu/" class="article-date">
  <time class="dt-published" datetime="2024-10-13T01:32:23.273Z" itemprop="datePublished">2024-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/is373_project/2024/10/13/ubuntu/">Install Ubuntu on a Mac: A Quick Guide</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/is373_project/images/ubuntuformac.jpg" alt="Ubuntu for mac screenshot"></p>
<p><strong>Ubuntu</strong> is an open-source operating system popular for development. Installing it on a Mac allows you to dual-boot or switch between macOS and Ubuntu, enhancing flexibility for development work.</p>
<h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><ul>
<li>A Mac with macOS</li>
<li><strong>USB drive (8GB+)</strong></li>
<li><strong>Ubuntu ISO</strong> from <a target="_blank" rel="noopener" href="https://ubuntu.com/download/desktop">here</a></li>
<li><strong>Balena Etcher</strong> for creating a bootable USB</li>
</ul>
<h2 id="Installation-Steps"><a href="#Installation-Steps" class="headerlink" title="Installation Steps"></a>Installation Steps</h2><h3 id="1-Create-a-Bootable-USB"><a href="#1-Create-a-Bootable-USB" class="headerlink" title="1. Create a Bootable USB"></a>1. Create a Bootable USB</h3><ol>
<li>Download the <strong>Ubuntu ISO</strong>.</li>
<li>Use <strong>Balena Etcher</strong> to flash the ISO to a USB drive.</li>
</ol>
<h3 id="2-Partition-Mac-Drive"><a href="#2-Partition-Mac-Drive" class="headerlink" title="2. Partition Mac Drive"></a>2. Partition Mac Drive</h3><ol>
<li>Open <strong>Disk Utility</strong>.</li>
<li>Create a new partition (20 GB+) in <strong>MS-DOS (FAT)</strong> format.</li>
</ol>
<h3 id="3-Boot-from-USB"><a href="#3-Boot-from-USB" class="headerlink" title="3. Boot from USB"></a>3. Boot from USB</h3><ol>
<li>Restart the Mac and hold <strong>Option (⌥)</strong> key during boot.</li>
<li>Select the USB drive from the boot menu.</li>
</ol>
<h3 id="4-Install-Ubuntu"><a href="#4-Install-Ubuntu" class="headerlink" title="4. Install Ubuntu"></a>4. Install Ubuntu</h3><ol>
<li>Choose <strong>Try Ubuntu</strong> from the USB boot.</li>
<li>Select <strong>Install Ubuntu</strong> and follow the prompts.</li>
<li>Install Ubuntu on the new partition.</li>
</ol>
<h3 id="5-Dual-Boot-Setup"><a href="#5-Dual-Boot-Setup" class="headerlink" title="5. Dual Boot Setup"></a>5. Dual Boot Setup</h3><ol>
<li>After installation, hold <strong>Option (⌥)</strong> on restart to choose between macOS and Ubuntu.</li>
</ol>
<p>For easier dual-booting, consider installing <strong>rEFInd</strong> from <a target="_blank" rel="noopener" href="https://www.rodsbooks.com/refind/">here</a>.</p>
<h2 id="Post-Installation"><a href="#Post-Installation" class="headerlink" title="Post-Installation"></a>Post-Installation</h2><ul>
<li>Run system updates:<pre><code class="bash">sudo apt update &amp;&amp; sudo apt upgrade
</code></pre>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kl63.github.io/is373_project/2024/10/13/ubuntu/" data-id="cm26wuoli0007fnoy651yg7jd" data-title="Install Ubuntu on a Mac: A Quick Guide" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-virtualizationvscontainerization" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/is373_project/2024/10/13/virtualizationvscontainerization/" class="article-date">
  <time class="dt-published" datetime="2024-10-13T01:32:23.273Z" itemprop="datePublished">2024-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/is373_project/2024/10/13/virtualizationvscontainerization/">Virtualization vs Containerization: Pros and Cons</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/is373_project/images/virtualvscontainer.webp" alt="Diagram"></p>
<p><strong>Virtualization</strong> and <strong>Containerization</strong> are both technologies used to run isolated applications on a single system. However, they differ in how they achieve isolation and resource utilization. Understanding the benefits and drawbacks of each can help determine the best approach for your infrastructure needs.</p>
<h2 id="Virtualization"><a href="#Virtualization" class="headerlink" title="Virtualization"></a>Virtualization</h2><p><strong>Virtualization</strong> involves creating virtual machines (VMs), where each VM runs its own operating system on top of a hypervisor. A hypervisor is the software that enables multiple VMs to share the same physical hardware. Each VM includes a full copy of an operating system (OS), applications, and necessary libraries.</p>
<h3 id="Pros"><a href="#Pros" class="headerlink" title="Pros"></a>Pros</h3><ul>
<li><strong>Full Isolation</strong>: VMs provide complete isolation between environments. Each VM has its own OS, making them secure and preventing one VM from affecting others.</li>
<li><strong>Flexibility</strong>: VMs can run different operating systems on the same physical hardware. This allows running Linux, Windows, and other OSes simultaneously.</li>
<li><strong>Resource Management</strong>: Hypervisors allow for the allocation of specific resources (CPU, memory, storage) to each VM, ensuring control over how much each VM consumes.</li>
<li><strong>Mature Technology</strong>: Virtualization has been around for decades and has well-established tools, best practices, and enterprise-grade support (e.g., VMware, Hyper-V).</li>
</ul>
<h3 id="Cons"><a href="#Cons" class="headerlink" title="Cons"></a>Cons</h3><ul>
<li><strong>Heavy Resource Usage</strong>: Each VM includes a full OS, which takes up significant CPU, memory, and storage resources. This can lead to overhead, especially when running multiple VMs.</li>
<li><strong>Slower Performance</strong>: Due to the additional layer of the OS and hypervisor, VMs tend to be slower compared to containerized applications.</li>
<li><strong>Longer Boot Times</strong>: Since VMs run a complete OS, they take longer to boot and initialize compared to containers, which are more lightweight.</li>
</ul>
<h2 id="Containerization"><a href="#Containerization" class="headerlink" title="Containerization"></a>Containerization</h2><p><strong>Containerization</strong> involves packaging applications and their dependencies into containers, which share the host system’s kernel but run in isolated user spaces. Containers are managed using container engines such as <strong>Docker</strong> or orchestration tools like <strong>Kubernetes</strong>.</p>
<h3 id="Pros-1"><a href="#Pros-1" class="headerlink" title="Pros"></a>Pros</h3><ul>
<li><strong>Lightweight</strong>: Containers share the host OS kernel, meaning they do not need to run a full OS. This makes them much more efficient in terms of resource usage (CPU, memory, and storage).</li>
<li><strong>Faster Startup</strong>: Containers can start up in seconds because they don’t need to boot an entire OS, which accelerates development and testing processes.</li>
<li><strong>Portability</strong>: Containers can run on any system that supports the container engine (e.g., Docker), regardless of the underlying infrastructure, ensuring consistency across environments (development, staging, production).</li>
<li><strong>Scalability</strong>: Containerization, especially when combined with orchestration platforms like Kubernetes, makes it easy to scale applications dynamically to meet demand.</li>
</ul>
<h3 id="Cons-1"><a href="#Cons-1" class="headerlink" title="Cons"></a>Cons</h3><ul>
<li><strong>Shared Kernel</strong>: Containers share the host OS kernel, meaning that any vulnerability in the kernel can potentially affect all containers running on the host, making them less isolated compared to VMs.</li>
<li><strong>Limited OS Diversity</strong>: Since containers share the host kernel, you cannot run a container with a different OS (e.g., you can’t run a Windows container on a Linux host without specific configurations).</li>
<li><strong>Less Mature</strong>: While containerization is gaining widespread adoption, it’s a newer technology compared to virtualization, and some legacy applications may not be easily containerized.</li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In summary, <strong>Virtualization</strong> offers strong isolation and the flexibility to run multiple OSes but comes with higher resource overhead and slower performance. It’s ideal for situations where you need complete OS-level isolation and security, or when running applications that aren’t designed to be containerized.</p>
<p>On the other hand, <strong>Containerization</strong> provides a more efficient, faster, and portable solution, making it excellent for microservices, development environments, and cloud-native applications. However, it sacrifices some of the isolation and flexibility that VMs provide. The best choice depends on your project’s needs, resource constraints, and operational goals.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kl63.github.io/is373_project/2024/10/13/virtualizationvscontainerization/" data-id="cm26wuolj0008fnoy5iljdnqc" data-title="Virtualization vs Containerization: Pros and Cons" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/is373_project/archives/2024/10/">October 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/is373_project/2024/10/13/12-factor/">Twelve Factor App</a>
          </li>
        
          <li>
            <a href="/is373_project/2024/10/13/containerization/">Containerization</a>
          </li>
        
          <li>
            <a href="/is373_project/2024/10/13/docker/">Docker</a>
          </li>
        
          <li>
            <a href="/is373_project/2024/10/13/dockervskubernetes/">Docker vs Kubernetes: Pros and Cons</a>
          </li>
        
          <li>
            <a href="/is373_project/2024/10/13/kernel/">Kernel Operating Systems</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Kevin Lin &amp; Sebastian Lopez<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/is373_project/" class="mobile-nav-link">Home</a>
  
    <a href="/is373_project/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/is373_project/js/jquery-3.6.4.min.js"></script>



  
<script src="/is373_project/fancybox/jquery.fancybox.min.js"></script>




<script src="/is373_project/js/script.js"></script>





  </div>
</body>
</html>